## 식별기반과 값 기반이냐? 

- 객체지향에서는 각 대신에 객체만 써야 한다. 
- 메소드가 값을 받으면 버그다.
- 그냥 숫자로 받으면 오류다. 객체로 값에 의미를 부여해야 한다. `new Money()`, `new Age()`
- 값은 항상 생성자의 인자로 넣을 때 밖에 못씀 

## 값을 쓰지 못하게 하는 것이 객체지향의 달성



## ESSENTIAL

- `hidestate`, 속성이 노출되면 값으로 사용되는 거다. 속성을 값으로 추출이 가능해지니까 객체지향이 무너진다. object literal 로 값 추출이 가능해짐 
- 기능의 캡슐화 `encapsulation` 외부에서는 추상화 된 형태로만 노출됨  (은닉과 캡슐화는 다른 이야기다) 

### 어떻게 하면 setAge 를 피할 수 있을까?

- 왜 setAge를 사용하는가? 어디에 왜 쓰는지 고민하지 않았기 때문에 setAdult, setChild 로 변할수는 없을까? 
- 더 깊이 생각해야지 기능의 캡슐화가 가능해짐 

###  Isolation of change 변화에 대한 격리



- ocp 개방폐쇄
- lsp 업캐스팅 안전 



## SRP를 준수하는 객체망이 문제를 해결

- 오퍼레이션 - 바깥에 노출되는 이름

- 메소드 - 실제 실행되는 메소드 

## 설계가 어려운점 

- 적당히 의존성을 분리하면서도 협력을 해야한다. 

### 객체의 생명 주기 전체에 걸친 의존성 

- 상속(extends) 상속받으면 강결합되기 때문에 크리티컬함, 상속을 쓸 때는 각오해야함
- 연관(association)? 소유모델 

### 각 오퍼레이션 실행 시 



## DIP (Dependency Inversion)

확장에는 열려(HardWorker가 아닌 Worker를 검사하므로)  있고, 의존성(다시 바꾸지는 않아도 됨)

DIP 와 OCP 는 연결됨 

## IOC(만 달성되면 나머지를 )

### 개념

1. Control = flow control(흐름제어)
2. 광의에서 흐름제어 = 프로그램 실행 통제
3. 동기 흐름 제어, 비동기 흐름제어 등 

### 문제점

1. 흐름 제어는 상태와 결합하여 진행됨
2. 상태 통제와 흐름제어 = 알고리즘 
3. 변화에 취약하고 구현하기도 어려움 

### 대안

1. 제어를 추상화하고 (제어를 모으려면 연역적추리, 패턴을 찾아야 한다) 
2. 개별 제어의 차이점만 외부에서 주입받는다. 

대리 운전(돈주는 것과 목적지를 이야기하는것이 어려운 것이 아니라, 운전을 잘 하는 놈에게 시키고, 나는 내가 잘하는 일을 하자) 

